#include <bits/stdc++.h>
using namespace std;

#define double long double
#define EPS 1e-9
struct CircleUnion {
  static const int maxn = 1e5 + 5;
  const double PI = acos((double)-1.0);
  int n;
  double x[maxn], y[maxn], r[maxn];
  int covered[maxn];
  vector<pair<double, double>> seg, cover;
  double arc, pol;

  inline int sign(double x) { return x < -EPS ? -1 : x > EPS; }
  inline int sign(double x, double y) { return sign(x - y); }
  inline double sqr(const double x) { return x * x; }
  inline double dist(double x1, double y1, double x2, double y2) {
    return sqrt(sqr(x1 - x2) + sqr(y1 - y2));
  }
  inline double angle(double A, double B, double C) {
    double val = (sqr(A) + sqr(B) - sqr(C)) / (2 * A * B);
    if (val < -1)
      val = -1;
    if (val > +1)
      val = +1;
    return acos(val);
  }

  CircleUnion() {
    n = 0;
    seg.clear(), cover.clear();
    arc = pol = 0;
  }
  void init() {
    n = 0;
    seg.clear(), cover.clear();
    arc = pol = 0;
  }
  void add(double xx, double yy, double rr) {
    x[n] = xx, y[n] = yy, r[n] = rr, covered[n] = 0, n++;
  }
  void getarea(int i, double lef, double rig) {
    arc += 0.5 * r[i] * r[i] * (rig - lef - sin(rig - lef));
    double x1 = x[i] + r[i] * cos(lef), y1 = y[i] + r[i] * sin(lef);
    double x2 = x[i] + r[i] * cos(rig), y2 = y[i] + r[i] * sin(rig);
    pol += x1 * y2 - x2 * y1;
  }
  double calc() {
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < i; j++) {
        if (!sign(x[i] - x[j]) && !sign(y[i] - y[j]) && !sign(r[i] - r[j])) {
          r[i] = 0.0;
          break;
        }
      }
    }
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (i != j && sign(r[j] - r[i]) >= 0 &&
            sign(dist(x[i], y[i], x[j], y[j]) - (r[j] - r[i])) <= 0) {
          covered[i] = 1;
          break;
        }
      }
    }
    for (int i = 0; i < n; i++) {
      if (sign(r[i]) && !covered[i]) {
        seg.clear();
        for (int j = 0; j < n; j++) {
          if (i != j) {
            double d = dist(x[i], y[i], x[j], y[j]);
            if (sign(d - (r[j] + r[i])) >= 0 ||
                sign(d - abs(r[j] - r[i])) <= 0) {
              continue;
            }
            double alpha = atan2(y[j] - y[i], x[j] - x[i]);
            double beta = angle(r[i], d, r[j]);
            pair<double, double> tmp(alpha - beta, alpha + beta);
            if (sign(tmp.first) <= 0 && sign(tmp.second) <= 0) {
              seg.push_back(pair<double, double>(2 * PI + tmp.first,
                                                 2 * PI + tmp.second));
            } else if (sign(tmp.first) < 0) {
              seg.push_back(pair<double, double>(2 * PI + tmp.first, 2 * PI));
              seg.push_back(pair<double, double>(0, tmp.second));
            } else {
              seg.push_back(tmp);
            }
          }
        }
        sort(seg.begin(), seg.end());
        double rig = 0;
        for (vector<pair<double, double>>::iterator iter = seg.begin();
             iter != seg.end(); iter++) {
          if (sign(rig - iter->first) >= 0) {
            rig = max(rig, iter->second);
          } else {
            getarea(i, rig, iter->first);
            rig = iter->second;
          }
        }
        if (!sign(rig)) {
          arc += r[i] * r[i] * PI;
        } else {
          getarea(i, rig, 2 * PI);
        }
      }
    }
    return pol / 2.0 + arc;
  }
} ccu;

int main() {
  ccu.init();
  ccu.add(0, 0, 1);
  ccu.add(2, 0, 1);
  cout << fixed << setprecision(9) << ccu.calc() << "\n";
  cerr << "\nTime elapsed: " << 1000 * clock() / CLOCKS_PER_SEC << "ms\n";
  return 0;
}
